import asyncio
import sqlite3
from datetime import datetime, timedelta

from aiogram import Bot, Dispatcher, types
from aiogram.filters import Command
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#                   ĞĞĞ¡Ğ¢Ğ ĞĞ™ĞšĞ˜
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

BOT_TOKEN = "8570594380:AAGDgUcpyZYOSc7xNkcK8KIYrxZGEf0T4Lw"
ADMIN_ID = 1333099097
TON_WALLET = "UQBJNtgVfE-x7-K1uY_EhW1rdvGKhq5gM244fX89VF0bof7R"

COST_PER_TICKET = 10000
CONTEST_DURATION_MINUTES = 10

bot = Bot(token=BOT_TOKEN)
dp = Dispatcher()

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#                   Ğ¡ĞĞ¡Ğ¢ĞĞ¯ĞĞ˜Ğ¯
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class TopUpState(StatesGroup):
    waiting_amount = State()

class SetPrizeState(StatesGroup):
    waiting_prize = State()

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#                   Ğ‘ĞĞ—Ğ Ğ”ĞĞĞĞ«Ğ¥
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

conn = sqlite3.connect("lottery.db", check_same_thread=False)
cur = conn.cursor()

cur.execute("""
CREATE TABLE IF NOT EXISTS users (
    user_id           INTEGER PRIMARY KEY,
    username          TEXT,
    balance           INTEGER DEFAULT 0,
    tickets           INTEGER DEFAULT 0,
    referrer_id       INTEGER,
    rewarded_referrer INTEGER DEFAULT 0
)
""")

cur.execute("""
CREATE TABLE IF NOT EXISTS contest (
    id        INTEGER PRIMARY KEY,
    prize     TEXT,
    is_active INTEGER DEFAULT 0,
    end_time  TEXT
)
""")
cur.execute("INSERT OR IGNORE INTO contest (id) VALUES (1)")

cur.execute("""
CREATE TABLE IF NOT EXISTS allowed_chats (
    chat_id   INTEGER PRIMARY KEY,
    title     TEXT,
    added_at  TEXT DEFAULT CURRENT_TIMESTAMP,
    added_by  INTEGER
)
""")
conn.commit()

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#                   ĞšĞ›ĞĞ’Ğ˜ĞĞ¢Ğ£Ğ Ğ«
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def user_kb():
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="ğŸ’³ ĞŸĞ¾Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ÑŒ", callback_data="topup")],
        [InlineKeyboardButton(text="ğŸŸ ĞšÑƒĞ¿Ğ¸Ñ‚ÑŒ Ğ±Ğ¸Ğ»ĞµÑ‚", callback_data="buy")],
        [InlineKeyboardButton(text="ğŸ“Š Ğ‘Ğ°Ğ»Ğ°Ğ½Ñ", callback_data="balance")],
        [InlineKeyboardButton(text="ğŸ¤ Ğ ĞµÑ„. ÑÑÑ‹Ğ»ĞºĞ°", callback_data="ref")],
    ])


def admin_kb():
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="â–¶ï¸ Ğ—Ğ°Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚ÑŒ ĞºĞ¾Ğ½ĞºÑƒÑ€Ñ", callback_data="admin_start")],
        [InlineKeyboardButton(text="â¹ ĞÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ ĞºĞ¾Ğ½ĞºÑƒÑ€Ñ", callback_data="admin_stop")],
        [InlineKeyboardButton(text="ğŸ† Ğ£ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ğ¿Ñ€Ğ¸Ğ·", callback_data="set_prize")],
        [InlineKeyboardButton(text="ğŸ‘¥ Ğ‘Ğ°Ğ»Ğ°Ğ½ÑÑ‹ Ğ¸Ğ³Ñ€Ğ¾ĞºĞ¾Ğ²", callback_data="admin_view_balances")],
    ])


async def contest_kb():
    me = await bot.get_me()  # â† Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½ await
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="ĞŸĞµÑ€ĞµĞ¹Ñ‚Ğ¸ Ğ² Ğ»Ğ¸Ñ‡Ğ½Ñ‹Ğ¹ ĞºĞ°Ğ±Ğ¸Ğ½ĞµÑ‚", url=f"https://t.me/{me.username}")],
    ])


def confirm_topup_kb(user_id: int, amount: int):
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text=f"âœ… ĞŸĞ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ´Ğ¸Ñ‚ÑŒ {amount}", callback_data=f"confirm_{user_id}_{amount}")],
        [InlineKeyboardButton(text="âŒ ĞÑ‚ĞºĞ»Ğ¾Ğ½Ğ¸Ñ‚ÑŒ", callback_data=f"reject_{user_id}")]
    ])


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#                   START
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

@dp.message(Command("start"))
async def cmd_start(msg: types.Message):
    args = msg.text.split()
    referrer_id = None
    if len(args) > 1:
        try:
            referrer_id = int(args[1])
        except:
            pass

    user = msg.from_user
    cur.execute(
        "INSERT OR IGNORE INTO users (user_id, username, referrer_id) VALUES (?, ?, ?)",
        (user.id, user.username, referrer_id)
    )
    conn.commit()

    cur.execute("SELECT is_active, prize, end_time FROM contest WHERE id = 1")
    contest = cur.fetchone()
    is_active, prize, end_time = contest if contest else (0, None, None)

    if msg.chat.type == "private":
        if user.id == ADMIN_ID:
            await msg.answer("ğŸ‘‘ ĞĞ´Ğ¼Ğ¸Ğ½-Ğ¿Ğ°Ğ½ĞµĞ»ÑŒ", reply_markup=admin_kb())
        else:
            await msg.answer("Ğ”Ğ¾Ğ±Ñ€Ğ¾ Ğ¿Ğ¾Ğ¶Ğ°Ğ»Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ² Ğ»Ğ¸Ñ‡Ğ½Ñ‹Ğ¹ ĞºĞ°Ğ±Ğ¸Ğ½ĞµÑ‚!", reply_markup=user_kb())
    else:
        if is_active:
            end = datetime.fromisoformat(end_time)
            remaining = end - datetime.utcnow()
            if remaining.total_seconds() <= 0:
                is_active = 0
            else:
                minutes, seconds = divmod(int(remaining.total_seconds()), 60)
                timer = f"{minutes:02d}:{seconds:02d}"
                text = f"ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğ¹ ĞºĞ¾Ğ½ĞºÑƒÑ€Ñ!\nĞŸÑ€Ğ¸Ğ·: {prize or 'Ğ½Ğµ ÑƒĞºĞ°Ğ·Ğ°Ğ½'}\nĞÑÑ‚Ğ°Ğ»Ğ¾ÑÑŒ: {timer}"
                await msg.answer(text, reply_markup=await contest_kb())
                return
        await msg.answer("ĞĞµÑ‚ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ğ¾Ğ³Ğ¾ ĞºĞ¾Ğ½ĞºÑƒÑ€ÑĞ°.")


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#                   /ADMIN
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

@dp.message(Command("admin"))
async def cmd_admin(msg: types.Message):
    if msg.from_user.id != ADMIN_ID:
        return await msg.answer("Ğ”Ğ¾ÑÑ‚ÑƒĞ¿ Ğ·Ğ°Ğ¿Ñ€ĞµÑ‰Ñ‘Ğ½")

    if msg.chat.type != "private":
        return await msg.answer("ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ° /admin Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ² Ğ»Ğ¸Ñ‡Ğ½Ñ‹Ñ… ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸ÑÑ….")

    await msg.answer("ğŸ‘‘ ĞĞ´Ğ¼Ğ¸Ğ½-Ğ¿Ğ°Ğ½ĞµĞ»ÑŒ", reply_markup=admin_kb())


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#                   ĞŸĞĞŸĞĞ›ĞĞ•ĞĞ˜Ğ•
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

@dp.callback_query(lambda c: c.data == "topup")
async def cb_topup(c: types.CallbackQuery, state: FSMContext):
    await c.message.answer("Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ ÑÑƒĞ¼Ğ¼Ñƒ Ğ¿Ğ¾Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ñ Ğ² AUR:")
    await state.set_state(TopUpState.waiting_amount)
    await c.answer()


@dp.message(TopUpState.waiting_amount)
async def process_topup_amount(msg: types.Message, state: FSMContext):
    if not msg.text.isdigit():
        return await msg.answer("Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾")

    amount = int(msg.text)
    if amount < 1:
        return await msg.answer("Ğ¡ÑƒĞ¼Ğ¼Ğ° Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ° Ğ±Ñ‹Ñ‚ÑŒ Ğ±Ğ¾Ğ»ÑŒÑˆĞµ 0")

    user = msg.from_user
    memo = f"{user.id}_{user.username or 'no_username'}"

    text = (
        f"ğŸ’³ ĞŸĞ¾Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚Ğµ <b>{amount}</b> AUR\n"
        f"ĞšĞ¾ÑˆĞµĞ»Ñ‘Ğº: <code>{TON_WALLET}</code>\n"
        f"Memo: <code>{memo}</code>\n\n"
        "ĞŸĞ¾ÑĞ»Ğµ Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ´Ğ° Ğ½Ğ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ ĞºĞ½Ğ¾Ğ¿ĞºÑƒ Ğ½Ğ¸Ğ¶Ğµ â†“"
    )

    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="Ğ¯ Ğ¾Ğ¿Ğ»Ğ°Ñ‚Ğ¸Ğ»", callback_data=f"paid_{amount}")]
    ])

    await msg.answer(text, parse_mode="HTML", reply_markup=kb)

    try:
        await bot.send_message(
            ADMIN_ID,
            f"ğŸŸ¢ Ğ—Ğ°Ğ¿Ñ€Ğ¾Ñ Ğ¿Ğ¾Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ñ\nĞÑ‚: @{user.username or user.id} ({user.id})\nĞ¡ÑƒĞ¼Ğ¼Ğ°: {amount} AUR",
            reply_markup=confirm_topup_kb(user.id, amount)
        )
    except Exception as e:
        print(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ñƒ: {e}")

    await state.clear()


@dp.callback_query(lambda c: c.data.startswith("paid_"))
async def cb_paid(c: types.CallbackQuery):
    amount = int(c.data.split("_")[1])

    await c.message.delete()
    await c.message.answer(f"ğŸ’¡ Ğ¡Ğ¾Ğ¾Ğ±Ñ‰Ğ¸Ğ»Ğ¸ Ğ¾Ğ± Ğ¾Ğ¿Ğ»Ğ°Ñ‚Ğµ {amount} AUR.\nĞĞ¶Ğ¸Ğ´Ğ°Ğ¹Ñ‚Ğµ Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ñ.")
    await c.answer()


@dp.callback_query(lambda c: c.data.startswith("confirm_"))
async def cb_confirm(c: types.CallbackQuery):
    if c.from_user.id != ADMIN_ID:
        return await c.answer("Ğ”Ğ¾ÑÑ‚ÑƒĞ¿ Ğ·Ğ°Ğ¿Ñ€ĞµÑ‰Ñ‘Ğ½", show_alert=True)

    _, uid_str, amt_str = c.data.split("_")
    user_id = int(uid_str)
    amount = int(amt_str)

    cur.execute("UPDATE users SET balance = balance + ? WHERE user_id = ?", (amount, user_id))
    conn.commit()

    await bot.send_message(user_id, f"âœ… ĞŸĞ¾Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¾ {amount} AUR")
    await c.message.edit_text(f"ĞŸĞ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¾: {amount} AUR â†’ {user_id}")
    await c.answer()


@dp.callback_query(lambda c: c.data.startswith("reject_"))
async def cb_reject(c: types.CallbackQuery):
    if c.from_user.id != ADMIN_ID:
        return await c.answer("Ğ”Ğ¾ÑÑ‚ÑƒĞ¿ Ğ·Ğ°Ğ¿Ñ€ĞµÑ‰Ñ‘Ğ½", show_alert=True)

    user_id = int(c.data.split("_")[1])
    await bot.send_message(user_id, "âŒ ĞŸĞ»Ğ°Ñ‚Ñ‘Ğ¶ Ğ¾Ñ‚ĞºĞ»Ğ¾Ğ½Ñ‘Ğ½.")
    await c.message.edit_text("ĞÑ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½Ğ¾")
    await c.answer()


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#                   ĞŸĞĞšĞ£ĞŸĞšĞ Ğ‘Ğ˜Ğ›Ğ•Ğ¢Ğ
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

@dp.callback_query(lambda c: c.data == "buy")
async def cb_buy(c: types.CallbackQuery):
    user = c.from_user

    if c.message.chat.type != "private":
        await c.answer("ĞŸĞ¾ĞºÑƒĞ¿ĞºĞ° Ğ±Ğ¸Ğ»ĞµÑ‚Ğ¾Ğ² Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ² Ğ›Ğ¡ Ğ±Ğ¾Ñ‚Ğ°")
        return

    cur.execute("SELECT balance FROM users WHERE user_id = ?", (user.id,))
    row = cur.fetchone()
    if not row or row[0] < COST_PER_TICKET:
        await c.message.answer(f"âŒ ĞĞµĞ´Ğ¾ÑÑ‚Ğ°Ñ‚Ğ¾Ñ‡Ğ½Ğ¾ ÑÑ€ĞµĞ´ÑÑ‚Ğ² (Ğ½ÑƒĞ¶Ğ½Ğ¾ {COST_PER_TICKET} AUR)")
        return await c.answer()

    cur.execute(
        "UPDATE users SET balance = balance - ?, tickets = tickets + 1 WHERE user_id = ?",
        (COST_PER_TICKET, user.id)
    )
    conn.commit()

    cur.execute("SELECT balance, tickets FROM users WHERE user_id = ?", (user.id,))
    bal, tik = cur.fetchone()

    username = f"@{user.username}" if user.username else f"ID{user.id}"

    await c.message.answer(
        f"âœ… ĞšÑƒĞ¿Ğ»ĞµĞ½ 1 Ğ±Ğ¸Ğ»ĞµÑ‚!\n\nĞ‘Ğ°Ğ»Ğ°Ğ½Ñ: {bal} AUR\nĞ‘Ğ¸Ğ»ĞµÑ‚Ğ¾Ğ²: {tik}"
    )

    # ĞĞ½Ğ¾Ğ½Ğ¸Ğ¼Ğ½Ğ¾Ğµ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ² Ğ³Ñ€ÑƒĞ¿Ğ¿Ñ‹
    text = "ğŸŸ ĞšÑ‚Ğ¾-Ñ‚Ğ¾ ĞºÑƒĞ¿Ğ¸Ğ» 1 Ğ±Ğ¸Ğ»ĞµÑ‚!"
    cur.execute("SELECT chat_id FROM allowed_chats")
    for row in cur.fetchall():
        chat_id = row[0]
        try:
            await bot.send_message(chat_id, text)
        except Exception as e:
            print(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸ Ğ² Ñ‡Ğ°Ñ‚ {chat_id}: {e}")

    await c.answer()


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#                   Ğ‘ĞĞ›ĞĞĞ¡
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

@dp.callback_query(lambda c: c.data == "balance")
async def cb_balance(c: types.CallbackQuery):
    cur.execute("SELECT balance, tickets FROM users WHERE user_id = ?", (c.from_user.id,))
    bal, tik = cur.fetchone() or (0, 0)
    await c.message.answer(f"ğŸ’° Ğ‘Ğ°Ğ»Ğ°Ğ½Ñ: {bal} AUR\nğŸŸ Ğ‘Ğ¸Ğ»ĞµÑ‚Ğ¾Ğ²: {tik}")
    await c.answer()


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#                   Ğ Ğ•Ğ¤Ğ•Ğ ĞĞ›Ğ¬ĞĞĞ¯ Ğ¡Ğ¡Ğ«Ğ›ĞšĞ
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

@dp.callback_query(lambda c: c.data == "ref")
async def cb_ref(c: types.CallbackQuery):
    user = c.from_user
    me = await bot.get_me()  # â† await
    link = f"https://t.me/{me.username}?start={user.id}"
    await c.message.answer(f"ğŸ¤ Ğ’Ğ°ÑˆĞ° Ñ€ĞµÑ„ĞµÑ€Ğ°Ğ»ÑŒĞ½Ğ°Ñ ÑÑÑ‹Ğ»ĞºĞ°:\n{link}")
    await c.answer()


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#                   ĞĞ”ĞœĞ˜Ğ â€” Ğ—ĞĞŸĞ£Ğ¡Ğš ĞšĞĞĞšĞ£Ğ Ğ¡Ğ
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

@dp.callback_query(lambda c: c.data == "admin_start")
async def admin_start(c: types.CallbackQuery):
    if c.from_user.id != ADMIN_ID:
        return await c.answer("Ğ”Ğ¾ÑÑ‚ÑƒĞ¿ Ğ·Ğ°Ğ¿Ñ€ĞµÑ‰Ñ‘Ğ½", show_alert=True)

    end = datetime.utcnow() + timedelta(minutes=CONTEST_DURATION_MINUTES)
    end_iso = end.isoformat()

    cur.execute("UPDATE contest SET is_active = 1, end_time = ? WHERE id = 1", (end_iso,))
    conn.commit()

    cur.execute("SELECT prize FROM contest WHERE id = 1")
    prize = cur.fetchone()[0] or "Ğ½Ğµ ÑƒĞºĞ°Ğ·Ğ°Ğ½"

    text = (
        f"ğŸ‰ <b>ĞšĞ¾Ğ½ĞºÑƒÑ€Ñ Ğ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½!</b>\n"
        f"ğŸ† ĞŸÑ€Ğ¸Ğ·: {prize}\n"
        f"â³ Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞ¸Ñ‚ÑÑ Ñ‡ĞµÑ€ĞµĞ· {CONTEST_DURATION_MINUTES} Ğ¼Ğ¸Ğ½ÑƒÑ‚"
    )

    cur.execute("SELECT chat_id FROM allowed_chats")
    for row in cur.fetchall():
        chat_id = row[0]
        try:
            await bot.send_message(chat_id, text, parse_mode="HTML", reply_markup=await contest_kb())
        except Exception as e:
            print(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸ Ğ² Ñ‡Ğ°Ñ‚ {chat_id}: {e}")
            await bot.send_message(ADMIN_ID, f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸ Ğ² Ñ‡Ğ°Ñ‚ {chat_id}: {e}")

    await c.answer("ĞšĞ¾Ğ½ĞºÑƒÑ€Ñ Ğ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½")


# ĞÑÑ‚Ğ°Ğ»ÑŒĞ½Ñ‹Ğµ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¸ (admin_stop, set_prize, admin_view_balances) Ğ¾ÑÑ‚Ğ°ÑÑ‚ÑÑ Ğ±ĞµĞ· Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğ¹, ĞºĞ°Ğº Ğ² Ñ‚Ğ²Ğ¾Ñ‘Ğ¼ ĞºĞ¾Ğ´Ğµ

async def main():
    print("Ğ‘Ğ¾Ñ‚ Ğ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½. ĞĞ´Ğ¼Ğ¸Ğ½ ID:", ADMIN_ID)
    await dp.start_polling(bot)


if __name__ == "__main__":
    asyncio.run(main())